//
//  databaseRelated.ts
//  atsight_apis
//
//  Created by Nathan Queme the 10/05/22
//

/*
export const used_keys = [

    // AccountMainData
    "account_id",
    "short_id",
    "account_name",
    "search_name",
    "username",
    "account_type",
    "certified",
    "has_photo",
    "has_header_photo",
    "geolocation",
    "image_data",
    "header_image_data",
    "s",

    // Profile
    "account_id",
    "additional_resources",
    "buttons",
    "comment_count",
    "email",
    "links",
    "phone_number",
    "menu_timetables",
    "post_count",
    "category_count",
    "related_items_count",
    "timetables",
    "description",
    "description_localization",

    // RelatedItem
    "account_id",
    "item_id",
    "name",
    "image_data",
    "created_date",
    "timetables",
    "description",
    "description_localization",
    "simple_location",
    "link",

    // PostCategory
    "metadata",
    "is_loaded",
    "posts",

    // PostCategoryMetadata
    "account_id",
    "category_id",
    "type",
    "score",
    "post_count",
    "c_index",
    "created_date",
    "update_date",
    "custom_type",

    // Post
    "post_id",
    "category_id",
    "account_id",
    "created_date",
    "image_data",
    "name",
    "saved_count",
    "comment_count",
    "comments_disabled",
    "geolocation",
    "geohash",
    "description",
    "description_localization",
    "tagged",
    "link_url",

    // Geolocation
    "city   ",
    "country",
    "iso",
    "region",
    "street",
    "zip",
    "latitude",
    "longitude",
    "auto_generated",

    // PhoneNumber
    "number",
    "country_code",
    "calling_code",

    // Timetables
    "type",
    "daily_timetables",
    "subject",
    "temporary_time",

    // DailyTimetable
    "day",
    "start_time",
    "end_time",
    "special_time",

    // Link
    "name",
    "url",

    // LanguageMetadata
    "name",
    "locale",

    // LocalizedText
    "language_metadata",
    "text",

    // ImageDimensions
    "image_type",
    "width",
    "height",

    // SearchResult
    "search_query",
    "type",
    "object",

    // DeviceInfo
    "device_id",
    "model",
    "os",
    "os_version",
    "registration_date",

    // UsageEvent
    "name",
    "start_date",
    "duration",
    "repetition_count",
    "fulfilled",

    // Session
    "id",
    "device_id",
    "start_date",
    "duration",
    "os_version",
    "version",
    "account_type",
    "installer_package",
    "events",
    "end_date_when_not_saved",

    // CoreError
    "type",
    "detail",
    "description",
]

export const dynamodb_reserved_words = [
    "ABORT",
    "ABSOLUTE",
    "ACTION",
    "ADD",
    "AFTER",
    "AGENT",
    "AGGREGATE",
    "ALL",
    "ALLOCATE",
    "ALTER",
    "ANALYZE",
    "AND",
    "ANY",
    "ARCHIVE",
    "ARE",
    "ARRAY",
    "AS",
    "ASC",
    "ASCII",
    "ASENSITIVE",
    "ASSERTION",
    "ASYMMETRIC",
    "AT",
    "ATOMIC",
    "ATTACH",
    "ATTRIBUTE",
    "AUTH",
    "AUTHORIZATION",
    "AUTHORIZE",
    "AUTO",
    "AVG",
    "BACK",
    "BACKUP",
    "BASE",
    "BATCH",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BIT",
    "BLOB",
    "BLOCK",
    "BOOLEAN",
    "BOTH",
    "BREADTH",
    "BUCKET",
    "BULK",
    "BY",
    "BYTE",
    "CALL",
    "CALLED",
    "CALLING",
    "CAPACITY",
    "CASCADE",
    "CASCADED",
    "CASE",
    "CAST",
    "CATALOG",
    "CHAR",
    "CHARACTER",
    "CHECK",
    "CLASS",
    "CLOB",
    "CLOSE",
    "CLUSTER",
    "CLUSTERED",
    "CLUSTERING",
    "CLUSTERS",
    "COALESCE",
    "COLLATE",
    "COLLATION",
    "COLLECTION",
    "COLUMN",
    "COLUMNS",
    "COMBINE",
    "COMMENT",
    "COMMIT",
    "COMPACT",
    "COMPILE",
    "COMPRESS",
    "CONDITION",
    "CONFLICT",
    "CONNECT",
    "CONNECTION",
    "CONSISTENCY",
    "CONSISTENT",
    "CONSTRAINT",
    "CONSTRAINTS",
    "CONSTRUCTOR",
    "CONSUMED",
    "CONTINUE",
    "CONVERT",
    "COPY",
    "CORRESPONDING",
    "COUNT",
    "COUNTER",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURSOR",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DATE",
    "DATETIME",
    "DAY",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFERRABLE",
    "DEFERRED",
    "DEFINE",
    "DEFINED",
    "DEFINITION",
    "DELETE",
    "DELIMITED",
    "DEPTH",
    "DEREF",
    "DESC",
    "DESCRIBE",
    "DESCRIPTOR",
    "DETACH",
    "DETERMINISTIC",
    "DIAGNOSTICS",
    "DIRECTORIES",
    "DISABLE",
    "DISCONNECT",
    "DISTINCT",
    "DISTRIBUTE",
    "DO",
    "DOMAIN",
    "DOUBLE",
    "DROP",
    "DUMP",
    "DURATION",
    "DYNAMIC",
    "EACH",
    "ELEMENT",
    "ELSE",
    "ELSEIF",
    "EMPTY",
    "ENABLE",
    "END",
    "EQUAL",
    "EQUALS",
    "ERROR",
    "ESCAPE",
    "ESCAPED",
    "EVAL",
    "EVALUATE",
    "EXCEEDED",
    "EXCEPT",
    "EXCEPTION",
    "EXCEPTIONS",
    "EXCLUSIVE",
    "EXEC",
    "EXECUTE",
    "EXISTS",
    "EXIT",
    "EXPLAIN",
    "EXPLODE",
    "EXPORT",
    "EXPRESSION",
    "EXTENDED",
    "EXTERNAL",
    "EXTRACT",
    "FAIL",
    "FALSE",
    "FAMILY",
    "FETCH",
    "FIELDS",
    "FILE",
    "FILTER",
    "FILTERING",
    "FINAL",
    "FINISH",
    "FIRST",
    "FIXED",
    "FLATTERN",
    "FLOAT",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FORMAT",
    "FORWARD",
    "FOUND",
    "FREE",
    "FROM",
    "FULL",
    "FUNCTION",
    "FUNCTIONS",
    "GENERAL",
    "GENERATE",
    "GET",
    "GLOB",
    "GLOBAL",
    "GO",
    "GOTO",
    "GRANT",
    "GREATER",
    "GROUP",
    "GROUPING",
    "HANDLER",
    "HASH",
    "HAVE",
    "HAVING",
    "HEAP",
    "HIDDEN",
    "HOLD",
    "HOUR",
    "IDENTIFIED",
    "IDENTITY",
    "IF",
    "IGNORE",
    "IMMEDIATE",
    "IMPORT",
    "IN",
    "INCLUDING",
    "INCLUSIVE",
    "INCREMENT",
    "INCREMENTAL",
    "INDEX",
    "INDEXED",
    "INDEXES",
    "INDICATOR",
    "INFINITE",
    "INITIALLY",
    "INLINE",
    "INNER",
    "INNTER",
    "INOUT",
    "INPUT",
    "INSENSITIVE",
    "INSERT",
    "INSTEAD",
    "INT",
    "INTEGER",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "INVALIDATE",
    "IS",
    "ISOLATION",
    "ITEM",
    "ITEMS",
    "ITERATE",
    "JOIN",
    "KEY",
    "KEYS",
    "LAG",
    "LANGUAGE",
    "LARGE",
    "LAST",
    "LATERAL",
    "LEAD",
    "LEADING",
    "LEAVE",
    "LEFT",
    "LENGTH",
    "LESS",
    "LEVEL",
    "LIKE",
    "LIMIT",
    "LIMITED",
    "LINES",
    "LIST",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATION",
    "LOCATOR",
    "LOCK",
    "LOCKS",
    "LOG",
    "LOGED",
    "LONG",
    "LOOP",
    "LOWER",
    "MAP",
    "MATCH",
    "MATERIALIZED",
    "MAX",
    "MAXLEN",
    "MEMBER",
    "MERGE",
    "METHOD",
    "METRICS",
    "MIN",
    "MINUS",
    "MINUTE",
    "MISSING",
    "MOD",
    "MODE",
    "MODIFIES",
    "MODIFY",
    "MODULE",
    "MONTH",
    "MULTI",
    "MULTISET",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NCLOB",
    "NEW",
    "NEXT",
    "NO",
    "NONE",
    "NOT",
    "NULL",
    "NULLIF",
    "NUMBER",
    "NUMERIC",
    "OBJECT",
    "OF",
    "OFFLINE",
    "OFFSET",
    "OLD",
    "ON",
    "ONLINE",
    "ONLY",
    "OPAQUE",
    "OPEN",
    "OPERATOR",
    "OPTION",
    "OR",
    "ORDER",
    "ORDINALITY",
    "OTHER",
    "OTHERS",
    "OUT",
    "OUTER",
    "OUTPUT",
    "OVER",
    "OVERLAPS",
    "OVERRIDE",
    "OWNER",
    "PAD",
    "PARALLEL",
    "PARAMETER",
    "PARAMETERS",
    "PARTIAL",
    "PARTITION",
    "PARTITIONED",
    "PARTITIONS",
    "PATH",
    "PERCENT",
    "PERCENTILE",
    "PERMISSION",
    "PERMISSIONS",
    "PIPE",
    "PIPELINED",
    "PLAN",
    "POOL",
    "POSITION",
    "PRECISION",
    "PREPARE",
    "PRESERVE",
    "PRIMARY",
    "PRIOR",
    "PRIVATE",
    "PRIVILEGES",
    "PROCEDURE",
    "PROCESSED",
    "PROJECT",
    "PROJECTION",
    "PROPERTY",
    "PROVISIONING",
    "PUBLIC",
    "PUT",
    "QUERY",
    "QUIT",
    "QUORUM",
    "RAISE",
    "RANDOM",
    "RANGE",
    "RANK",
    "RAW",
    "READ",
    "READS",
    "REAL",
    "REBUILD",
    "RECORD",
    "RECURSIVE",
    "REDUCE",
    "REF",
    "REFERENCE",
    "REFERENCES",
    "REFERENCING",
    "REGEXP",
    "REGION",
    "REINDEX",
    "RELATIVE",
    "RELEASE",
    "REMAINDER",
    "RENAME",
    "REPEAT",
    "REPLACE",
    "REQUEST",
    "RESET",
    "RESIGNAL",
    "RESOURCE",
    "RESPONSE",
    "RESTORE",
    "RESTRICT",
    "RESULT",
    "RETURN",
    "RETURNING",
    "RETURNS",
    "REVERSE",
    "REVOKE",
    "RIGHT",
    "ROLE",
    "ROLES",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROW",
    "ROWS",
    "RULE",
    "RULES",
    "SAMPLE",
    "SATISFIES",
    "SAVE",
    "SAVEPOINT",
    "SCAN",
    "SCHEMA",
    "SCOPE",
    "SCROLL",
    "SEARCH",
    "SECOND",
    "SECTION",
    "SEGMENT",
    "SEGMENTS",
    "SELECT",
    "SELF",
    "SEMI",
    "SENSITIVE",
    "SEPARATE",
    "SEQUENCE",
    "SERIALIZABLE",
    "SESSION",
    "SET",
    "SETS",
    "SHARD",
    "SHARE",
    "SHARED",
    "SHORT",
    "SHOW",
    "SIGNAL",
    "SIMILAR",
    "SIZE",
    "SKEWED",
    "SMALLINT",
    "SNAPSHOT",
    "SOME",
    "SOURCE",
    "SPACE",
    "SPACES",
    "SPARSE",
    "SPECIFIC",
    "SPECIFICTYPE",
    "SPLIT",
    "SQL",
    "SQLCODE",
    "SQLERROR",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "START",
    "STATE",
    "STATIC",
    "STATUS",
    "STORAGE",
    "STORE",
    "STORED",
    "STREAM",
    "STRING",
    "STRUCT",
    "STYLE",
    "SUB",
    "SUBMULTISET",
    "SUBPARTITION",
    "SUBSTRING",
    "SUBTYPE",
    "SUM",
    "SUPER",
    "SYMMETRIC",
    "SYNONYM",
    "SYSTEM",
    "TABLE",
    "TABLESAMPLE",
    "TEMP",
    "TEMPORARY",
    "TERMINATED",
    "TEXT",
    "THAN",
    "THEN",
    "THROUGHPUT",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE",
    "TINYINT",
    "TO",
    "TOKEN",
    "TOTAL",
    "TOUCH",
    "TRAILING",
    "TRANSACTION",
    "TRANSFORM",
    "TRANSLATE",
    "TRANSLATION",
    "TREAT",
    "TRIGGER",
    "TRIM",
    "TRUE",
    "TRUNCATE",
    "TTL",
    "TUPLE",
    "TYPE",
    "UNDER",
    "UNDO",
    "UNION",
    "UNIQUE",
    "UNIT",
    "UNKNOWN",
    "UNLOGGED",
    "UNNEST",
    "UNPROCESSED",
    "UNSIGNED",
    "UNTIL",
    "UPDATE",
    "UPPER",
    "URL",
    "USAGE",
    "USE",
    "USER",
    "USERS",
    "USING",
    "UUID",
    "VACUUM",
    "VALUE",
    "VALUED",
    "VALUES",
    "VARCHAR",
    "VARIABLE",
    "VARIANCE",
    "VARINT",
    "VARYING",
    "VIEW",
    "VIEWS",
    "VIRTUAL",
    "VOID",
    "WAIT",
    "WHEN",
    "WHENEVER",
    "WHERE",
    "WHILE",
    "WINDOW",
    "WITH",
    "WITHIN",
    "WITHOUT",
    "WORK",
    "WRAPPED",
    "WRITE",
    "YEAR",
    "ZONE ",
]
function logReservedWords() {
    dynamodb_reserved_words.filter(reserved_word => {
        if (used_keys.includes(reserved_word.toLowerCase())) {
            console.log(reserved_word)
        }
    })
}
function logUsedReservedWords() {
    used_keys.filter(key => {
        if (dynamodb_reserved_words.includes(key.toLowerCase())) {
            console.log(key)
        }
    })
}
*/

import { IterableObject, Post, Profile, RelatedItem } from "../data"
import { MathematicalOperation } from "../types"


export const used_reserved_words = [
    "day",
    "duration",
    "name",
    "number",
    "object",
    "region",
    "text",
    "type",
]


/** Replaces reserved words to be handled in combination with handleReservedWordsIfAny()
 *
 * e.g. : 
 * - "name, created_date" returns "#name, created_date" because "name" is a reserved word.
 * - "account_id, created_date" returns "account_id, created_date"
 * 
 * N.B. : Does not works for nested reserved words 
 */
export function catchReservedWords(part: string) {
    return part
        .replace("day", "#day")
        .replace("duration", "#duration")
        .replace("name", "#name")
        .replace("number", "#number")
        .replace("object", "#object")
        .replace("region", "#region")
        .replace("text", "#text")
        .replace("type", "#type")
}

/** Generate the expressionAttributeNames object to handle each reserved word if any.
 * 
 * e.g.: 
 * - "name, account_id, created_date" returns { "#name": "name" } because "name" is a reserved word 
 * - "account_id, created_date" returns undefinde
 * 
 * N.B. : Does not works for nested reserved words 
 */
export function handleReservedWords(part: string) {
    let expressionAttributeNames: IterableObject | undefined
    let keys: string[] = part.replace(/\s+/g, '').split(",")


    keys.forEach(key => {
        if (used_reserved_words.some(reserved_word => { return key === reserved_word })) {
            if (expressionAttributeNames === undefined) expressionAttributeNames = {}
            expressionAttributeNames[`#${key}`] = key

        }
    })

    return expressionAttributeNames
}

/** Change the part so it will only return the description_localization in the given human language if any. 
 * 
 * e.g.: 
 * - "created_date, description_localization" and hl = "fr" returns "created_date, description_localization["fr"]"
*/
export function handleHumanLanguage(part: string, hl?: string) {
    return hl ? part.replace("description_localization", `description_localization.${hl.replace(/\s+/g, '').toLowerCase()}`) : part
}

/** HACK to format the response.
 
- TRANSFORMS :
    {
        "name": "Post about something",
        "fr": "Bonjour, c'est une description."
    }

- INTO : 
    {
        "name": "Post about something",
        "description_localization": {
            "fr": "Bonjour, c'est une description."
        }
    }
*/
export function formatResponseToHandleHL(reponse: any, hl: string) {
    let formatted_hl = hl.replace(/\s+/g, '').toLowerCase()
    let hl_description = reponse[formatted_hl] as string
    delete reponse[formatted_hl]

    if ((hl_description ?? "") !== "") {
        reponse[`description_localization`] = {}
        reponse[`description_localization`][formatted_hl] = hl_description
    }

    return reponse
}

export function getOperationSign(operation: MathematicalOperation) {
    return operation === "add" ? '+' : (operation === "subtract" ? '-' : undefined)
}